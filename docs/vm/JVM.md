# JVM

1. XXX.java 文件首先需要经过编译器编译，生成 XXX.class 字节码文件。

2. Java 程序中访问 XXX 这个类时，需要先通过 ClassLoader(类加载器)将 XXX.class 加载到 JVM 的内存中。

3. JVM 中的内存可以划分为若干个不同的数据区域，主要分为：程序计数器、虚拟机栈、本地方法栈、堆、方法区。其中程序计数器、虚拟机栈、本地方法栈是线程私有的，堆、方法区是线程共享的。

## 虚拟机规范

描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。虚拟机的具体实现有很多，比如Sun公司的HotSpot、JRocket、IBMJ9、以及我们非常熟悉的AndroidDalvik和ART等。

### 程序计数器

记录 Java 当前线程执行的位置。用于线程上下文切换、分支操作、循环操作、跳转、异常处理等。

程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。

### 虚拟机栈

#### 栈帧

栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。

一个线程包含多个栈帧，而每个栈帧内部包含局部变量表、操作数栈、动态连接、返回地址等

##### 局部变量表

局部变量表是变量值的存储空间，我们调用方法时传递的参数，以及在方法内部创建的局部变量都保存在局部变量表中

##### 操作数栈

用于执行操作数运算的栈。

##### 动态链接

支持方法调用过程中的动态连接（Dynamic Linking）。

在一个 class 文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其所在内存地址中的直接引用，而符号引用存在于方法区中。

##### 返回地址

帮助当前方法恢复它的上层方法执行状态。

### 本地方法栈

本地方法栈和虚拟栈基本相同，只不过是针对本地（native）方法。在有些虚拟机的实现中已经将两者合二为一了（比如HotSpot）

### 堆

存放对象实例。

新生代、老年代。新生代又被划分为 Eden 和 Survivor 区。

### 方法区

JVM 规范里规定的运行时数据区。存储已经被 JVM 加载的类信息（版本、字段、方法、接口）、常量、静态变量、即时编译器编译后的代码和数据。

HotSpot在JDK1.7以前使用“永久区”（或者叫Perm区）来实现方法区，在JDK1.8之后“永久区”就已经被移除了，取而代之的是一个叫作“元空间（metaspace）”的实现方式。

