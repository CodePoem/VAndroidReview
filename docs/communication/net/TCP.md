# TCP

## 报文段

* 原端口和目的端口
* 序号（seq）和确认序号（ack）
* 数据偏移／首部长度 —— 表明报文段头部的长度，不包含任何可选字段为20字节，最大60字节
* 保留
* 控制位

URG：紧急指针标志
ACK：确认序号标志
PSH：push标志
RST：重置连接标志
SYN：同步序号
FIN：finish标志

* 窗口 —— 滑动窗口大小，用于流量控制
* 校验和
* 紧急指针

## 通信过程

### 三次握手

1. Clinet -> Server，SYN = 1，seq = X，Client进入SYN_SENT状态。
2. Server -> Client，ACK = 1，ack = X + 1，SYN = 1，seq = Y，Server进入SYN_RCVD状态。
3. Client -> Server， Client 检验 ACK = 1 和 ack = X + 1，ACK = 1，ack = Y + 1，Client进入ESTABLISHED状态，Server校验ACK = 1和ack = Y + 1，Server进入ESTABLISHED状态。

为什么握手需要三次？

确认双方收发数据能力。

举个打电话的例子：

A -> B ：喂，你能听到吗？
B -> A ：我能听到。你能听到吗？ —— 对于 B 来说，确认 A 的发送能力和 B 的接收能力。
A -> B ：能听到。 —— 对于 A 来说，首先确认 A 的发送能力和 B 的接收能力，然后确认 B 的发送能力和 A 的接收能力。

最后，因为 A 的发送能力和 B 的接收能力双方都确认了，所以 B 能听到，那么 B 就确认了 B 的发送能力和 A 的接收能力。

### 四次挥手

1. 主机1 -> 主机2，FIN = 1，seq = M，主机1 进入FIN_WAIT_1状态。
2. 主机2 -> 主机1，ACK = 1，ack = M + 1，主机2进入CLOSE_WAIT状态。
3. 主机2 -> 主机1，FIN = 1，seq = N，主机2进入LAST_ACK状态。
4. 主机1 -> 主机2，ACK = 1，ack = N + 1，主机1进入TIME_WAIT状态，等待2MSL（2个最长报文段寿命），主机2进入CLOSED状态，

为什么挥手需要四次？

确认双方数据都传输完毕，双方确认关闭达到一致。

举个挂电话的例子：

A -> B ：我这说完了，你还有什么想说的吗？—— 对于 A 来说，确认 A 传输完毕。
B -> A ：好的。（可能还有一些事想说） —— 对于 B 来说，确认 A 传输完毕。
B -> A ：我这也说完了。 —— 对于 B 来说，确认 B 传输完毕。
A -> B ：好的，你挂吧。（等说两句话的时间，没收到回复，也挂了）。 —— 对于 A 来说，确认 B 传输完毕。

B 收到消息后即可认为双方达到一致，可以关闭，但是 A 不知道 B 收到消息，只能按最坏的情况 B 没有收到，等待 B 重新确认关闭。

## 可靠传输

### 流量控制

#### 概念

让发送方的发送速率不要太快，要让接收方来得及接收。

#### 解决方案

滑动窗口：

Client 返回的 ACK 都会告知 Server 当前 Client 窗口的大小，Server 会根据窗口的大小来控制发送数据和向前滑动。

### 拥塞控制

#### 概念

解决多主机之间共享网络时出现的拥塞问题。

#### 解决方案

##### 慢开始算法+拥塞避免算法

慢开始算法：

慢开始指基数小，但拥塞窗口 cwnd 大小指数增长，到设定的阈值ssthresh变为拥塞避免算法。

拥塞避免算法：

拥塞避免算法的拥塞窗口cwnd大小为线性增长，遇到网络阻塞，减小阈值ssthresh，重新变为慢开始算法。

###### 快重传+快恢复

快重传：

接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器到期。

快恢复：

当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始阈值ssthresh减半。

遇到网络阻塞，减小阈值ssthresh，但不执行慢开始算法，而是基于阈值ssthresh的一半开始执行拥塞避免算法。
