# HashMap

散列表：数组 + 链表

数组：hashCode方法；初始容量为 16，负载因子为0.75
链表：equals方法，头插法（1.8 尾插法）

特点：

- 不保证映射顺序
- 允许null键和null值
- 非同步，非线程安全

## 进阶机制

### 碰撞冲突解决

#### 减少碰撞

hash 算法和负载因子的合理设计都是为了避免过多的碰撞冲突。

常规的设计是把桶的大小设计为素数，相对来说素数导致冲突的概率要小于合数。
在HashMap中，哈希桶数组 table 的长度 length 大小必须为2的n次方(一定是合数)，这是一种非常规的设计。
HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化（因为这样（数组长度-1）正好相当于一个“低位掩码”），同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。

- 取模运算 (length - 1) & hash

key.hashCode() 值范围从-2147483648到2147483648。一个40亿的数组，内存是放不下的，何况 HashMap 的数组初始大小才16，所以这个散列数值是不能直接拿来用的，用之前还需要先对数组长度进行取模运算，得到的余数才可以使用来访问数组下标。

“与”操作的结果就是散列值的高位全部归零，只保留低位值。

但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。甚至极端情况恰好使最后几个低位呈现规律性重复。

- hash运算 hash = (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)

“扰动函数”。

右位移16位，正好是32bit的一半，自己的高半区和低半区做异或，就是为了混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，尽可能的减少碰撞。

#### 提高碰撞后的解决效率

Java8之前：

- 链表——查找 O(1)+O(n)
- 链表头插法——插入 O(1)+O(1)

Java8：

- 链表——查找 O(1)+O(n)，当链表长度大于等于TREEIFY_THRESHOLD（默认为8，源码注释里有写，是经过科学统计的分布概率）时，将链表转换为红黑树——插入、查找 O(1)+O(logn)，当然小于UNTREEIFY_THRESHOLD（默认为6）时，又会转回链表以达到性能均衡。

- 链表尾插法——插入 O(1)+O(n)

红黑树：

1. 每个节点不是红色就是黑色的
2. 根节点和叶子节点都是黑色
3. 如果一个节点是红色，那么它的子节点都是黑色。（反之不一定）
4. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

变色

左旋

右旋
