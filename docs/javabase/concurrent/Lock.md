# Lock

## 概念

### 悲观锁和乐观锁

- 悲观锁（独占锁/排它锁也是悲观锁的思想）。它假设一定会发生冲突，因此获取到锁之后会阻塞其他等待线程。悲观锁的代表是 synchronized。

这么做的好处是简单安全，但是挂起线程和恢复线程都需要转入内核态进行，这样做会带来很大的性能开销。然而在真实环境中，大部分时候都不会产生冲突。悲观锁会造成很大的浪费。

- 乐观锁。它假设不会产生冲突，先去尝试执行某项操作，失败了再进行其他处理（一般都是不断循环重试）。乐观锁的代表实现是 CAS。

这种锁不会阻塞其他的线程，也不涉及上下文切换，性能开销小。

### 公平锁和非公平锁

- 公平锁。在加锁前先检查有无排队的线程，按排队顺序去获得锁。

- 非公平锁。加锁前不考虑排队问题，直接尝试获取锁，获取不到再去队尾排队。

### 可重入锁和不可重入锁

- 可重入锁。线程可以进入它已经拥有的锁的同步代码块。

- 不可重入锁。如果当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。

## 隐式锁 synchronized

隐式锁就是我们最常使用的 synchronized 关键字。

***synchronized 是一种独占锁(悲观锁)、非公平锁、可重入锁。***

每个对象有一个锁和一个等待队列，锁只能被一个线程持有，其他需要锁的线程需要阻塞等待。锁被释放后，对象会从队列中取出一个并唤醒，唤醒哪个线程是不确定的，不保证公平性。

### 类锁和对象锁

- 在修饰静态方法时，锁的是类对象，如 Object.class。

- 修饰非静态方法时，锁的是对象，即 this。修饰方法块时，锁的是括号里的对象。

多个线程是可以同时执行同一个synchronized实例方法的，只要它们访问的对象是不同的。

synchronized 锁住的是对象而非代码，只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会被同步顺序访问。

此外，需要说明的，synchronized方法不能防止非synchronized方法被同时执行，所以，一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。

### 实现原理

Monitor机制

一个对象在内存中包含三部分：对象头，实例数据和对齐填充。

其中 Java 对象头包含两部分：

- Class Metadata Address（类型指针）。存储类的元数据的指针。虚拟机通过这个指针找到它是哪个类的实例。

- Mark Word（标记字段）。存出一些对象自身运行时的数据。包括哈希码，GC 分代年龄，锁状态标志等。

Mark Word 有一个字段指向 monitor 对象。monitor 中记录了锁的持有线程，等待的线程队列等信息。前面说的每个对象都有一个锁和一个等待队列，就是在这里实现的。
monitor 对象由 C++ 实现。其中有三个关键字段：

_owner 记录当前持有锁的线程
_EntryList 是一个队列，记录所有阻塞等待锁的线程
_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程。

Monitor的操作机制如下：

1. 多个线程竞争锁时，会先进入 EntryList 队列。竞争成功的线程被标记为 Owner。其他线程继续在此队列中阻塞等待。
2. 如果 Owner 线程调用 wait() 方法，则其释放对象锁并进入 WaitSet 中等待被唤醒。Owner 被置空，EntryList 中的线程再次竞争锁。
3. 如果 Owner 线程执行完了，便会释放锁，Owner 被置空，EntryList 中的线程再次竞争锁。

#### JVM 对 synchronized 的处理

如何将 synchronized 和 monitor 关联起来？

- 如果同步的是代码块，编译时会直接在同步代码块前加上 monitorenter 指令，代码块后加上 monitorexit 指令。这称为显示同步。

- 如果同步的是方法，虚拟机会为方法设置 ACC_SYNCHRONIZED 标志。调用的时候 JVM 根据这个标志判断是否是同步方法。

#### JVM 对 synchronized 的优化

synchronized 是重量级锁，由于消耗太大，虚拟机对其做了一些优化。

##### 自旋锁与自适应自旋

在许多应用中，锁定状态只会持续很短的时间，为了这么一点时间去挂起恢复线程，不值得。我们可以让等待线程执行一定次数的循环，在循环中去获取锁。这项技术称为自旋锁，它可以节省系统切换线程的消耗，但仍然要占用处理器。在 JDK1.4.2 中，自选的次数可以通过参数来控制。 JDK 1.6又引入了自适应的自旋锁，不再通过次数来限制，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。

##### 锁消除

虚拟机在运行时，如果发现一段被锁住的代码中不可能存在共享数据，就会将这个锁清除。

例子：

```java
public void add(String str1, String str2) {
    StringBuffer sb = new StringBuffer();
    sb.append(str1).append(str2);
}
```

众所周知，StringBuffer 的 append 方法是同步方法，但是在这个 add 方法中，StringBuffer 不会存在共享资源竞争的情况，因为其他线程并不会访问到它。这就符合了 “代码上要求同步，但不可能存在共享数据竞争” 的条件。因此虽然这里有锁，但是可以安全地清除掉，避免了锁的获取释放带来的性能消耗。

##### 锁粗化

当虚拟机检测到有一串零碎的操作都对同一个对象加锁时，会把锁扩展到整个操作序列外部。

例子：

```java
public void add(String str1, String str2, String str3) {
    StringBuffer sb = new StringBuffer();
    sb.append(str1);
    sb.append(str2);
    sb.append(str3);
}
```

同样是 StringBuffer ，JVM 检测到有一连串操作都对同一个对象（sb）加锁时，就会把锁进行粗化处理，扩展同步范围，这样从一个 append() 到最后一个，只需要加一次锁就可以了。

##### 轻量级锁

对绝大部分的锁来说，在整个同步周期内都不存在竞争。如果没有竞争，轻量级锁可以使用 CAS 操作避免使用互斥量的开销。

##### 偏向锁

偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁。

## 显式锁 Lock

显式锁主要包含两个接口：Lock 和 ReadWriteLock，主要实现类分别为 ReentrantLock 和 ReentrantReadWriteLock，这两个类都是基于 AQS(AbstractQueuedSynchronizer) 实现的。

### ReentrantLock

***ReentrantLock 是一种乐观锁、可重入锁，并且支持公平锁（FairSync）和非公平锁（NoFairSync）。***

### ReentrantReadWriteLock

读写锁有一个读锁和一个写锁，分别对应读操作和锁操作。