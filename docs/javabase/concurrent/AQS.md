# AQS (AbstractQueuedSynchronizer)

AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。

juc其实就是包的缩写(java.util.concurrnt)，juc包中很多可阻塞的类都是基于AQS构建的。在AQS中实现了对等待队列的默认实现，子类只要重写部分的代码即可实现(大量用到了模板代码)

## 重要成员变量

- state 用于表示锁现在的状态，用 volatile 修饰，保证内存可见。同时所用对 state 的操作都是使用 CAS 进行的。state 为0表示没有任何线程持有这个锁，线程持有该锁后将 state 加1，释放时减1。多次持有释放则多次加减。

- 双向链表。除了头结点外，每一个节点都记录了线程的信息，代表一个等待线程。这是一个 FIFO 的链表。

### 实现

#### ReentrantLock

#### ReentrantReadWriteLock

写锁有一个读锁和一个写锁，分别对应读操作和锁操作。读写分离，保证了可以并发读取，这大大提高了效率。

特性：

- 只有一个线程可以获取到写锁。在获取写锁时，只有没有任何线程持有任何锁才能获取成功；
- 如果有线程正持有写锁，其他任何线程都获取不到任何锁；
- 没有线程持有写锁时，可以有多个线程获取到读锁。

读写锁虽然有两个锁，但实际上只有一个等待队列。

- 获取写锁时，要保证没有任何线程持有锁；
- 写锁释放后，会唤醒队列第一个线程，可能是读锁和写锁；
- 获取读锁时，先判断写锁有没有被持有，没有就可以获取成功；
- 获取读锁成功后，会将队列中等待读锁的线程挨个唤醒，知道遇到等待写锁的线程位置；
- 释放读锁时，要检查读锁数，如果为0，则唤醒队列中的下一个线程，否则不进行操作。
